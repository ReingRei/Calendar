import * as fs from 'fs';
export class Config {
  private static _requested: Array<string> = [];

  public static get DB_TYPE():
    | 'mysql'
    | 'mariadb'
    | 'postgres'
    | 'cockroachdb'
    | 'sqlite'
    | 'mssql'
    | 'sap'
    | 'oracle'
    | 'cordova'
    | 'nativescript'
    | 'react-native'
    | 'sqljs'
    | 'mongodb'
    | 'aurora-data-api'
    | 'aurora-data-api-pg'
    | 'expo'
    | 'better-sqlite3'
    | 'capacitor' {
    return (process.env.DB_TYPE as any) || 'sqlite';
  }

  public static get isProduction(): boolean {
    return process.env.IS_PRODUCTION == 'true';
  }

  public static get DB_PORT(): number {
    return process.env.DB_PORT ? parseInt(process.env.DB_PORT) : 3306;
  }

  public static get DB_HOST(): string {
    if (Config._requested.indexOf('DB_HOST') < 0) {
      Config._requested.push('DB_HOST');
      return process.env.DB_HOST;
    } else {
      return null;
    }
  }

  public static get DB_USER(): string {
    if (Config._requested.indexOf('DB_USER') < 0) {
      Config._requested.push('DB_USER');
      return process.env.DB_USER;
    } else {
      return null;
    }
  }

  public static get DB_PASS(): string {
    if (Config._requested.indexOf('DB_PASS') < 0) {
      Config._requested.push('DB_PASS');
      return process.env.DB_PASS;
    } else {
      return null;
    }
  }

  public static get DB_NAME(): string {
    if (Config._requested.indexOf('DB_NAME') < 0) {
      Config._requested.push('DB_NAME');
      return process.env.DB_NAME;
    } else {
      return null;
    }
  }

  // Certificados
  private static getCertificatePlainText(content: string) {
    if (content && content.startsWith('-----') && content.endsWith('-----')) {
      return {
        exists: true,
        plain: content,
      };
    } else if (content && fs.existsSync(content)) {
      return {
        exists: true,
        plain: fs.readFileSync(content).toString('utf-8'),
      };
    } else {
      return { exists: false };
    }
  }

  public static get CERT_SIGN_TOKEN_KEY() {
    const cert = Config.getCertificatePlainText(process.env.CERT_SIGN_TOKEN_KEY);
    if (!cert.exists)
      throw new Error(
        'É necessário uma chave privada para assinar os tokens, para gerar utilize o comando: openssl genpkey -algorithm RSA -out ./certificados/jwt_private.pem -pkeyopt rsa_keygen_bits:2048',
      );

    return cert.plain;
  }

  public static get CERT_SIGN_TOKEN_PUB() {
    const cert = Config.getCertificatePlainText(process.env.CERT_SIGN_TOKEN_PUB);
    if (!cert.exists)
      throw new Error(
        'É necessário uma chave publica para verificar a assinatura dos tokens, para gerar utilize o comando: openssl rsa -pubout -in ./certificados/jwt_private.pem -out ./certificados/jwt_public.pem',
      );

    return cert.plain;
  }

  public static get CERT_SIGN_DATA_KEY() {
    const cert = Config.getCertificatePlainText(process.env.CERT_SIGN_DATA_KEY);
    if (!cert.exists)
      throw new Error(
        'É necessário um certificado para a criptografia dos dados, para gerar utilize o comando: openssl req -x509 -sha256 -nodes -days 73000  -newkey rsa:4096 -keyout ./certificados/data.key -out ./certificados/data.crt',
      );

    return cert.plain;
  }

  public static get CERT_SIGN_DATA_PUB() {
    const cert = Config.getCertificatePlainText(process.env.CERT_SIGN_DATA_PUB);
    if (!cert.exists)
      throw new Error(
        'É necessário um certificado para a criptografia dos dados, para gerar utilize o comando: openssl req -x509 -sha256 -nodes -days 73000  -newkey rsa:4096 -keyout ./certificados/data.key -out ./certificados/data.crt',
      );

    return cert.plain;
  }

  public static get AWS_ACCESS_KEY_ID(): string {
    return process.env.AWS_ACCESS_KEY_ID;
  }

  public static get AWS_SECRET_ACCESS_KEY(): string {
    return process.env.AWS_SECRET_ACCESS_KEY;
  }
  API_LOCALIZACAO;

  /// RabbitMQ
  public static get RMQ_HOST(): string {
    return process.env.RMQ_HOST;
  }

  public static get RMQ_USER(): string {
    return process.env.RMQ_USER;
  }

  public static get RMQ_PASS(): string {
    return process.env.RMQ_PASS;
  }

  /// Captcha
  public static get CAPTCHA_PROVIDER(): 'HCAPTCHA' | 'RECAPTCHA' {
    return process.env.CAPTCHA_PROVIDER as any;
  }

  /// MONGODB
  public static get MONGODB(): string {
    return process.env.MONGODB;
  }

  public static get API_LOCALIZACAO(): string {
    return process.env.API_LOCALIZACAO;
  }

  /// FIREBASE
  public static get FIREBASE_CONFIG(): any {
    return {
      apiKey: process.env.APIKEY,
      authDomain: process.env.AUTHDOAMIN,
      projectId: process.env.PROJECTID,
      storageBucket: process.env.STORAGEBUCKET,
      messagingSenderId: process.env.MESSAGINGSENDERID,
      appId: process.env.APPID,
    };
  }
}
